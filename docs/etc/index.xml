<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TIL</title>
    <link>https://example.com/docs/etc/</link>
    <description>Recent content on TIL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://example.com/docs/etc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://example.com/docs/etc/005_rabbitMq/</link>
      <pubDate>Sat, 27 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/docs/etc/005_rabbitMq/</guid>
      <description>기술 블로그 정리 # RabbitMQ란? # RabbitMQ란? # AMQP를 따르는 오픈소스 메시지 브로커 메시지를 많은 사용자에게 전달하거나, 요청에 대한 처리 시간이 길 때, 해당 요청을 다른 API에게 위임하고 빠른 응답을 할때 많이 사용한다. AMQP # Advanced Message Queueing Protocol MQ의 오픈소스에 기반한 표준 프로토콜을 의미한다.&#xA;RabbitMQ 개념 # 1. Producer # 메시지를 생성하고 발송하는 주체 이 메시지가 Queue에 저장된다. Producer는 Queue에 직접 접근하지 않고, 항상 Exchange를 통해 접근하게 된다. 2.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.com/docs/etc/004_sonarQube/</link>
      <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/docs/etc/004_sonarQube/</guid>
      <description>기술 블로그 정리 # 코드 분석 도구 적용기 - 3편, SonarQube 적용하기 # SonarQube란? # 정적 코드 분석 도구 # 정적 프로그램 분석(static program analysis) : 실제 실행 없이 컴퓨터 소프트웨어를 분석하는 것 정적 분석은 코드의 모든 부분을 확인할 수 있지만, 실행 환경에서의 상태를 정확히 알 수 없기 때문에 실행할 때에만 알 수 있는 데이터가 필요한 경우 정확히 분석하기 어렵다. SonarQube # 20개 이상의 프로그래밍 언어에서 버그, 코드 스멜, 보안 취약점을 발견할 목적으로 정적 코드 분석으로 자동 리뷰를 수행하기 위한 지속적인 코드 품질 검사용 오픈 소스 플랫폼 소나소스(SonarSource)가 개발 소나큐브는 중복 코드, 코딩 표준, 유닛 테스트, 코드 커버리지, 코드 복잡도, 주석, 버그 및 보안 취약점의 보고서를 제공 정적 코드 분석 도구 중 하나로, 레퍼런스가 많고, Github 또는 Jenkins와의 연동을 통해 자동 정적 코드 분석을 구성할 수 있다.</description>
    </item>
    <item>
      <title></title>
      <link>https://example.com/docs/etc/003_huge_traffic_handling/</link>
      <pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate>
      <guid>https://example.com/docs/etc/003_huge_traffic_handling/</guid>
      <description>우아콘 2023, 우아한 형제들 세션 정리 # 대규모 트랜잭션을 처리하는 배민 주문시스템 규모에 따른 진화 # 성장통들 # 개선 대상 리스트 단일 장애 포인트 대용량 데이터 대규모 트랜잭션 복잡한 이벤트 아키텍처 단일 장애 포인트 # 루비라 불리는 중앙 집중 저장소에 모든 시스템이 의존 중앙 저장소의 부하 발생 해결 # 중앙 저장소 -&amp;gt; 각 시스템을 분리하는 프로젝트 진행 시스템 간 통신은 Message Queue 기반으로 통신 특정 시스템의 장애는 메시지 발행의 실패로 끝 정리 # 중앙 집중 DB의 장애, 전체 시스템의 전파 -&amp;gt; MQ를 이용한 이벤트 기반 통신으로 시스템간 영향도를 분리</description>
    </item>
    <item>
      <title></title>
      <link>https://example.com/docs/etc/002_tps/</link>
      <pubDate>Thu, 28 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://example.com/docs/etc/002_tps/</guid>
      <description>내가 만든 서비스는 얼마나 많은 사용자가 이용할 수 있을까? # 성능 테스트는 왜 해야 할까? # 성능 테스트 : 서비스의 성능적인 부분을 측정하기 위해 실행되는 작업 애플리케이션의 성능을 측정 : 점진적인 부하를 가하는 과정 속에서 더 이상 처리량이 증가하지 않을 때, 그 수치를 측정하고 해석하는 것 목적 현재 애플리케이션이 최대 몇 명의 사용자를 수용할 수 있는지 측정하고, 그 결과가 최초 목표한 성능에 부합하는지 알아내기 위함 목표 성능에 부합하지 않는다면 어떤 지점에서 병목이 발생하고, 이를 해결하기 위해 무엇을 해야 하는지 분석하여 개선함으로써 최종적으로 서비스가 중단되는 상황 없이 제공될 수 있도록 가용성을 높이는 것 서비스가 빠른지 느린지 어떻게 알 수 있을까?</description>
    </item>
    <item>
      <title></title>
      <link>https://example.com/docs/etc/001_jmeter/</link>
      <pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate>
      <guid>https://example.com/docs/etc/001_jmeter/</guid>
      <description>설치 # Jmeter 설치 터미널에서 수행 brew install jmeter jmeter 실행 터미널에서 수행 open /opt/homebrew/bin/Jmeter 사용방법 # Request Number Of Thread (users) : 몇 개의 쓰레드(유저 수)로 테스트할 지 Ramp-up period (seconds) : {Number of Thread} 만큼의 쓰레드를 몇초에 걸쳐서 만들 지 Loop Count : 요청을 몇번을 반복할 지 (설정된 값에 따라 Number of Threads * Ramp-up period 만큼 요청을 다시 보낸다.) Response Label : Sampler 명 Samples : 샘플 실행 수 (Number of Threads X Ramp-up period) Average : 평균 걸린 시간 (ms) Min : 최소 Max : 최대 Std.</description>
    </item>
  </channel>
</rss>
